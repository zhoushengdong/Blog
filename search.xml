<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[产品体验报告：微信读书，让阅读不再孤独]]></title>
    <url>%2Fblog%2F2020%2F09%2F16%2F%E4%BA%A7%E5%93%81%E4%BD%93%E9%AA%8C%E6%8A%A5%E5%91%8A%EF%BC%9A%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%EF%BC%8C%E8%AE%A9%E9%98%85%E8%AF%BB%E4%B8%8D%E5%86%8D%E5%AD%A4%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[与其他的阅读APP不同，微信读书从一开始就含着金钥匙出生，背靠微信，主打社交化阅读。本文主要从产品概述、市场状况、需求分析、产品分析、竞品比较等几个维度对微信读书展开了梳理探究 体验环境 目标产品： 微信读书（IOS） 版本：5.0.1 设备：iPhone XR 操作系统：iOS 14 时间：2020/09/15 产品简介口号（slogan）：让阅读不再孤独 简介：热门小说阅读听书必备 产品介绍：微信读书是基于微信关系链的官方阅读应用，同时支持iPhone和iPad两大终端平台。在提供极致阅读体验的同时，为用户推荐合适的书籍，并可查看微信好友的读书动态、与好友讨论正在阅读的书籍等。 功能特性： 【精心打磨的阅读体验】EPUB的精致书籍排版，你还可以随心个性化你的专属阅读风格 【和好友发现优质好书】帮你发现下一本适合你的好书。书海茫茫，不妨让微信好友来帮你完成筛选，快速找到优质好书 【和好友讨论交流碰撞】在阅读中与好友的想法邂逅，跟好友交流你的阅读感想，碰撞出更多火花。这一次，让阅读不再孤单 【和好友比拼阅读时长】严肃的阅读游戏，让你轻松了解自己的阅读时长，在阅读中不仅收获知识，更收获与好友比拼的成就感 总结：从微信读书官方对于该产品的描述，可以看出微信读书产品亮点应该是：优质的书籍质量与读书体验，准确的书籍推荐，在看书过程中与微信好友的互动。 市场状况政策2017年国家版权局正式印发《版权工作“十三五”规划》，规划指出要坚持实施版权严格保护、推动版权产业发展、健全版权工作体系三大基本原则，并且在2020年初步实现中国特色的版权强国【1】。在国家政策的推动的环境下，而书籍版权保护任务作为《版权工作“十三五”规划》中的一部分，使得盗版书籍资源被一定程度的打压。 在《中国图书馆学会关于开展2020年全民阅读工作的通知》中，有以下2个推广活动：策划优选数字阅读项目，持续打造“数字阅读之门”和创新阅读推广形式，展现当代全民阅读新风采【2】。这2个推广活动，体现了数字阅读被社会所认可，而且成为了推广人们阅读的方式。 总结：在政策上，国家打击了盗版的书籍资源。并且把推广数字阅读作为一种推进社会文明发展的一种方式 经济根据艾瑞咨询《2019年中国移动阅读发展趋势研究报告》可以发现，中国的数字阅读市场规模依旧在稳步增长。移动阅读市场占数字阅读市场相当大的比重，且增长率较大，因此所占的比重将会更大 图片来自艾瑞咨询《2019年中国移动阅读发展趋势研究报告》 社会根据中国互联网络信息中心（CNNIC）发布的第45次《中国互联网络发展状况统计报告》显示，截至2020年3月，我国网民规模为9.04亿，互联网普及率达64.5%，我国手机网民规模达8.97亿，我国网民使用手机上网的比例达99.3%【3】。 而根据下图阅读网络服务使用状况则发现，中国数字阅读的网民数量仍然有较大提升空间 图片来自艾瑞咨询《2019年中国移动阅读发展趋势研究报告》 技术2018年网络文学作者数量达到875万，为提供高质量的网络文学作品提供了坚实的基础。而且国家5G建设以及网络的全覆盖为移动阅读用户随时随地享受服务提供了基础条件 图片来自艾瑞咨询《2019年中国移动阅读发展趋势研究报告》 需求分析用户画像 年龄分布：主要是20～29岁年龄的人群，即90后 数据来自百度指数 性别分布：男性用户居多 数据来自百度指数 地区分布：主要分布在经济发达的省份与直辖市 数据来自百度指数 使用时间段：从天数上看，呈现周期波动，工作日的使用量要大于周末使用量；从小时上看，用户使用集中在9:00至10:00和14:00至16:00 数据来自百度指数 阅读的书籍：此处我根据微信读书的2020年9月16日总榜前200（实际上只有194本）进行分析，得出以下结论：小说类书籍共占比51.0%，经典小说占比38.1%，网络小说占比12.9%。社会人文心理学类书籍占比26.8%，人物传记与历史类书籍占比12.3%，技术科普类书籍占比5.2%，金融理财类书籍占比4.6% 总结：微信读书的主要用户以一线二线城市90后居多。使用时间多是在上班或学习的时候。而且微信读书的用户读书偏好也同市面上一些在线阅读app不同 例如，番茄小说的人气排行榜中绝大多数是网文小说，这些小说绝大部分没有纸质版本；而在微信读书总榜中，小说占比只有51.0%，并且这些小说有相当一部分是名著。而根据阅读书籍类别的分布，可以把微信读书的用户分成以下几种情况： 通过微信读书来看小说打发时间 通过微信读书来学习更多的知识，提高自身修养 通过微信读书来学习专业知识，来获得职业发展或提升生活品质 使用场景根据之前的用户画像，我得出以下微信读书用户可能的使用场景： 产品分析产品功能结构 阅读功能 阅读功能作为读书软件最基本的功能，因为这是用户使用阅读类app的最基本的需求。在微信读书中有多个方式打开一本书进行阅读。最快的步骤只需要在打开微信读书后再点击一次即可进入书籍阅读界面 微信读书阅读界面简洁大方，不类似于一些传统电子书阅读app会在页面下方跳出广告。同时在阅读的过程中，有很多其他读者的想法。这一些想法在用户阅读碰到不明白的字词时起到了翻译解释的作用。 这种用户自己生产的内容，提升了其他用户的阅读体验，算得上是一种良性循环。比如我在阅读《三国义演》时，很容易碰到一些古代的地名、官职而这时候点击用户想法就省去了我去搜索字词意思的环节，是的我的阅读体验不被中断。当然，想法是否可见可以在设置界面关闭 点击阅读界面，显示出阅读界面的设置。在此处可以发现，微信读书在尽力避免使用文字来对按钮进行解释，使用户能够更加专注于阅读，也使得页面显得更为简洁。我认为这一个地方是，微信读书的一个亮点。虽然没有了文字的解释，有可能会使用户产生困惑，但我认为这利大于弊 在微信读书广告部分，因为我使用的是免费无限卡，有时在阅读的过程中会呈现广告。弹出广告时点击关闭按钮即可关闭广告，虽然会些许影响用户阅读的连贯性。但考虑到我已在微信读书读了10多本书却没有付费，个人认为，在免费读的情况下，弹出类似于微信读书的广告是可以接受的 新增功能：纸书购买 该功能是微信读书5.0.0之后新加入的功能，根据本人使用情况发现有四个入口可以通往纸质书购买界面： 纸书购买入口 书籍信息页面 在阅读界面时，点击，上方会出现当前书籍购买按钮（这个入口不是必定会出现） 点击发现页面的纸书特价按钮 “我”界面下的购物车按钮 使用场景 用户想买书，先通过微信读书来试读，然后再从微信读书下单买书 用户在看书，但是发现由于电子书的限制，例如不方便做笔记和屏幕限制，想通过微信读书的纸书购买功能进行买书 用户看完了一本书，并且从中受益良多，想要买一本纸质书使得更有纪念意义与仪式感 添加纸书购买的原因与优势 有纸质书籍购买的用户土壤。根据本人在 4.1 用户画像处的分析得知，微信读书的用户群体与番茄阅读的用户群体是不同的。微信读书中的读者有相当一部分并不是网络小说的读者，他们在微信读书上所读的书，大部分有对应的纸质版本。这一用户群体特性，是纸书购买业务能够实现的前提条件。 用户使用场景切换。用户在购买纸书时，一般都会通过搜索（去豆瓣）该书本的网络评价，然后决定书本的购买。但是在微信读书中，用户就可以通过在微信读书中试读甚至读完一本书。在这种情况下，用户如果有购买纸书的意愿，就极大地缩短了消费者旅程，使得用户很容易完成纸质书的购买。 给腾讯生态下的京东进行引流。微信读书中用户对纸质书的购买意愿自然而然就能够引流至同属于腾讯生态下的京东商城。然而，它的竞品却难以实现，主要有以下2个困难：1.用户群体不同，目标用户所阅读的书籍并没有纸质版本；2.纸质书商城选择困难，并且难以得到同等的支持 竞品是否会添加该功能个人认为是否添加该功能，应该考虑一下3个问题： 用户有购买纸质书的动机吗？ 将用户引流至哪里购买纸质书？ 用户基数大吗？ 微信读书的竞品可以分为两类：网络小说阅读app和出版书在线阅读app 网络小说阅读app中，类似番茄小说。它平台上的小说内容，绝大部分并没有纸质书版本，因此没有购买渠道。即便是有纸质书购买渠道，由于该类作品一般章节数目都是动则几百甚至上千。购买它的全套纸质书对读者来说这会是不菲的支出，例如斗罗大陆第一套小说纸质版需要花费320元 出版书在线阅读app中，类似于当当云阅读以及网易蜗牛阅读。我个人认为该类app是有添加该功能的潜力的。因为其用户都是出版电子书的读者。而且两者都已经建立了自己都购物平台（当当网、网易严选有纸质书的商品购买） 不过这两个app在用户流量上，与微信读书对比相差巨大。再者，当当云阅读是2013年发布的软件，已经步入的成熟期甚至衰退期，用户群体的量上很难有大的突破了 反观，网易蜗牛读书是2017年发布，目前依旧有较大的成长空间。而且它采用了新颖的以读书时长收费方式，且平台中有许多高质量的心得分享 若网易蜗牛读书像其公司的网易云音乐以及网易严选一样，对准的目标用户是一二线城市注重商品性价比的年青上班族和追求品质生的的小资文艺青年，那么很容易从中进行引流，达成用户群体量上的突破。并且当用户读得一时兴起，再配合网易严选类似的纸质书购买服务，则很有可能下单 纸书购买的未来方向 由于纸书购买功能上线还不久，在微信读书中还有很多书并不能够购买。因此微信读书应该会为更多书城中的书添加购买选择 既然微信读书将社交作为产品亮点，那么本人猜测会在今后推出和朋友组队购买书，或者将书放入愿望单可以让朋友购买的功能 竞争对手 此处我将为微信读书的对竞品，网络小说类app，以番茄小说为例 使用场景 数据来自百度指数 从上表可以看出，微信读书的搜索指数在工作日会上升，在休息日会下降。然而番茄小说却恰恰相反，在工作日会下降，在休息日反而上升。看第二张图表，可以发现有番茄小说的高峰期在10:00至16:00与19:00至22:00，同时包含了上班时间与下班休息时间。而微信是9:00至10:00和14:00至16:00，只包含上班时间 此处体现了两者在用户使用的场景上的不同： 番茄小说是在工作时间，打发时间的碎片化阅读工具。同时它也是用户在休息时间娱乐消遣的工具 微信读书则没有这么强的娱乐属性，它属于打发时间的碎片化和学习自我提升的阅读工具 用户群体分布 地域分布 数据来自百度指数 从上图看出两者在用户人群地域以及年龄的分布上亦有很大的差别。根据微信读书的用户地域分布，可以发现用户主要集中在长江三角州，珠江三角洲，以及北京地区。剩余用户群体在华中地区呈现零散分布。而番茄小说却不同，它不仅在微信读书集中的长江三角洲、珠江三角洲、北京地区有这许多的用户，而且在华中的川渝地区更是有巨大的用户群体 年龄分布 数据来自百度指数 从年龄分布上看，微信读书的用户主要为20至29岁的群体，占比高达65.7%。而番茄小说的用户年龄最多集中在30至39岁，占39.6%。值得一提的是，番茄小说中40至49岁的用户占据了它22.3%的用户群体 因为互联网用户一般多集中在20至39岁区间，40至49岁的人群大概只占了互联网用户的15.2%，可见番茄小说在40至49岁年龄段相当受欢迎了。当使用百度指数的TGI指标进行观察是，能够发现两者用户年龄段在30岁左右产生交叉 个人猜测有以下2个猜测：1.网络小说更受30至49岁群体欢迎，而微信读书有相当一部分用户是出版书读者，因此导致了用户群体的年龄分布不同。2.番茄小说由于受到来自于其公司头部产品的引流，因此导致了它与微信读书不同的年龄分布 首先看第一种猜测： 以上我展示了微信读书（蓝色）、番茄小说（绿色）、起点小说（黄色）、qq阅读（粉色）、掌阅（紫色）的年龄分布图。其中起点小说、qq阅读、掌阅与番茄小说类似都是网络小说阅读app 从中对比可以发现，新加入的三个app虽然在30至49岁的年龄段对比微信读书占优，但是与番茄小说特殊的年龄分布相比依旧有很大的差距。并且新加入的三者其用户最多集中的年龄段依旧是在20至29岁。因此我认为，猜测1对用户群体年龄分布的影响有限，绝不是主要因素 接下来看第二种猜测： 以上展示了微信读书（蓝色）、番茄小说（绿色）、今日头条（黄色）、抖音（粉色）。根据上图可以发现，今日头条和抖音没有类似于微信读书的用户年龄集中，在30岁以后的年龄段用户群体有相当大的一个占比 考虑到今日头条与抖音在用户量的级别上远远大于番茄小说。因此在今日头条和抖音有偏向于40至49岁年龄的引流方向的话，是完全可以实现的 因此我更倾向于猜测2是导致番茄小说用户群体年龄段不同的主要因素 用户需求此处我拿微信读书的top200总榜、男生小说榜、女生小说榜 与 番茄小说的各类排行榜 进行比较 如果只拿男生小说榜，女生小说榜与番茄小说各类榜单进行比较，则会发现微信读书和番茄小说在网文小说方面用户群体有很大的重合，是明显的竞争对手 并且根据网站上公布的数据来看，番茄小说在网络小说阅读上的用户要远大于微信读书。但是将微信读书总榜进行比较时，则会发现微信读书有相当一部分用户喜欢阅读非网络小说类型的文学作品，这些用户是番茄小说所没有的 总结SWOT分析优势微信读书背靠微信，能够借助于微信的资源得到发展。这是相比于它的竞争对手难以想象的优势 根据本人在app store图书类产品的排行榜上来看前20名的app中，微信读书占据第五位。而且其他app可以归类为一下几种：听书app、网络小说app、漫画app、知识付费app。而只有微信读书是有经营出版书在线阅读的服务，因此我认为微信读书目前在出版书的电子版本阅读领域已经处于领先地位 劣势微信读书的一大亮点是社交属性的读书，然而根据本人的使用体验来看，熟人社交的微信并没有给微信读书带来社交上的优势，想法会使用户在看书，发表想法甚至查看好友排名时有心理负担（此处观点可能有些片面） 机会 微信是属于各个年龄段的群体都有使用的app。但是微信读书的用户却主要集中在90后。那么能否将30岁以上，特别是40至49岁的微信用户转变为微信读书的用户呢 国家文化政策的推进，使得微信读书等正版图书app在一定程度上受到了保护 威胁目前微信读书的主要用户集中在20至29岁区间，且多为居住在一二线城市。于此同时，它的竞争对手网易蜗牛读书定位的群体也是20至29岁的文艺青年，那么是否会在今后发生类似于qq音乐与网易云音乐的竞争 引用资料： 2017, 国家版权局印发《 版权工作“十三五”规划 》 2020, 中国图书馆学会关于开展2020年全民阅读工作的通知 我国网民规模突破9亿 手机上网比例达99.3%]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见异常状态的产品设计]]></title>
    <url>%2Fblog%2F2019%2F04%2F10%2F%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E7%8A%B6%E6%80%81%E7%9A%84%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[产品的设计过程中，大部分只专注于主操作流程、主页面、分支流程、小页面和页面的不同状态。当用户停留任何一个界面，进行任何一个操作都可能发生异常状态。产品小白们常常忽略对异常状态展示的设计，或者每次做需求都去设计一次各异常状态的展示页面，这样效率不高且会导致不同功能模块、流程，同一异常状态，异常展示设计不一致。 产品应该对公司内同一产品或产品线规定异常状态的全局设计规范，以提升效率。 常见异常状态罗列 网络异常 空数据 加载失败 操作失败 消耗大量流量时 服务器异常 搜索无结果 无权限 功能建设中 内容被删除 下面针对这10种异常状态分别展开说明。 网络异常存在两种用户场景： 场景1： 网络异常时，用户打开App，这种情况App会出现异常状态提示给用户，这是App主动告知行为； 场景2： 用户点击操作时，由于网络异常，这时候通过交互反馈给用户，这是App被动告知行为。 当无网络时，用户打开App，通常有三种方式提醒用户当前网络异常。 tips提示，通过tips提示用户当前网络不可用，tips使用场景一般为用户打开后，界面停留在首页， 且首页以列表形式展示，这样的话，tips才能合理的融入到界面中，常见使用这种布局方式的有微信、qq等。 使用toast提示用户网络异常，同时提示用户可以去使用非数据影响的的操作。例如网易云音乐，当无网络时候，告知用户可以去正常听已下载的音乐。 使用对话框，引导用户进入设置页面，关闭飞行模式或者打开Wi-Fi，例如美团进入首页后的对话框提示。当前无网络时，用户点击操作时，无法正常使用产品，这时候通常有两种处理方式。 点击操作后，进入下一级界面，以缺省页的形式提醒用户当前网络异常。 当前操作界面上使用toast提示。 总结： 个人觉得，不管是主动或被动告知用户网络异常，若非IM工具时，其他产品均可以采用 toast提示形式告知用户即可。 空数据 空数据一共分为两种类型，分别为初始状态和清空状态。 初始状态用户首次使用，没有任何内容数据时，需要用户进行某种操作才能产生内容的界面，这时候需要提示用户需要进行某种操作才会出现内容。 空数据一般对于初始状态的设计，常规做法是简单的插画配合简洁的文案，必要的时候给出引导用户操作行为的按钮。现在流行的设计趋势是插画越轻量越简单越好，以免抢夺了文案信息。清空状态当用户清空当前的页面内容，产生了空界面，这时候需要有明确的提示告知用户出现当前页面当原因，且告知用户该如何处理。 空数据（清空）清空状态的界面和初始状态设计很相似，唯一不同的是文案的提示。有的产品设计直接把清空状态的界面按照初始状态来设计，这样也是可以的，缺点就是没有告知用户产生空状态原因是初始化还是清空所致。 加载失败在加载过程中，App向服务器请求数据，如果是网络原因导致，则使用网络异常的设计规范。如果非网络异常原因，则可能因为服务器异常导致接口请求不到数据，从而导致加载失败。 这种情况可使用toast告知用户加载失败的原因。 操作失败任何操作行为的交互界面都伴随着操作失败的概率。当用户操作失败时，在当前页面给予一个反馈，告知用户操作失败，最好告知用户操作失败的原因，让用户知道接下来如何避免操作失败。可以使用toast提示 或 对话框。 消耗大量流量时当涉及需要消耗大量流量数据时，且非Wi-Fi情况下，这时候需要告知用户。常见的例如：看视频，听/下载歌曲、视频通话、下载上传文件等。 网易云音乐在非Wi-Fi情况下，下载音乐时，通过对话框，告知用户当前使用数据流量，同时提供操作可继续下载，也提供通过办理新业务解决数据流量的问题。 服务器异常因为服务器异常是小概率事件，但是也会发生。当服务器异常时，且用户在操作过程中，出现这种情况，一般可设计为对话框提示，明确告知用户，服务器出现问题，让用户稍后重试。 搜索无结果用户在搜索过程中，除了出现正常的匹配结果，还存在无匹配结果的情况，针对搜索无结果的情况，要给予用户操作无结果的提示。几乎搜索的搜索无结果状态都是在内容区出现对应的提示（插图） 无权限无权限的场景，通常适用b端产品，对于不同组织架构的企业员工，会存在不同的权限。当然最好的方案是在App上面过滤掉无法查看的内容，但是存在员工间的转发行为，这时候无权限的员工，点击进入，则显示暂无权限查看的提示页面。 功能建设中一般App功能正在开发中，这种情况不会在App界面中展示出来，只有完全开发完毕并上线后才会出现在App上。但是也有一些产品的特殊业务，会将一些未开发的功能展示出来，即出现对应的提示。 一般采用提示语或插图提示。 举个例子：一个电商App主页，你想要上一个自营功能，其实功能还没完善好。但是市场那边已经跟用户说了会上这个功能，而且时间也差不多到了，为了给用户一个缓冲，就需要这样一个页面。 我跟你说下另一种情况：一开始就有这个自营功能，但是迭代过程中发现这个功能问题很多，也不符合用户心智模型要大改。这个时候，你难道直接先删掉这个功能么？肯定不合适！其中一个解决办法就是：加一个功能升级页面，敬请期待。 内容被删除有的时候，由于文件或者页面内容被删除，由于文件或者页面内容的上一级页面有缓存，所以当用户点击进入时，会出现文章/文件被删除的情况。已被删除的异常状态，常见的设计是用户进入新页面出现对应的插画和标题提示。]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[竞品分析：「每日优鲜」与「盒马鲜生」]]></title>
    <url>%2Fblog%2F2018%2F04%2F20%2F%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%AF%8F%E6%97%A5%E4%BC%98%E9%B2%9C%E4%B8%8E%E7%9B%92%E9%A9%AC%E9%B2%9C%E7%94%9F%2F</url>
    <content type="text"><![CDATA[行业情况 生鲜电商一直是个特殊的存在，虽然其市场份额目前每年上4万亿，但是，生鲜电商十分难做。原因主要有两点： 1.高成本：生鲜产品保质期短，性状不稳定，易变质，这对物流配送提出了挑战。除了干线运输需要全程冷链物流外，在最后一公里配送也需要专用保温材料进行包装配送。这造成了每单物流成本高达30-40元，是常规电商的10倍左右 2.高损耗：生鲜的易腐性引起的损耗高达20%-50%，损耗可发生在交易链条的任何环节。这些高昂的成本最后都会让消费者买单，造成客单价高。同时，高成本、高损耗又让生鲜电商无利可赚 所以说生鲜电商真的很难做。 从上述数据可以看出，现阶段的K12在线教育行业处于政策利好时期；并且从2013年以来互联网巨头和初创公司都开始发力K12在线教育，K12产品如雨后春笋般涌现；其次K12在线教育最大涉及人群约22亿，市场空间充裕 市场分析 市场规模预测 累计用户数：2017-08-05 ~ 2019-07-22 | 上线 合计：33.46万人 7日注册用户占比：2019-07-15 ~ 2019-07-21 | 过去 合计：91.24% 注册用户首日付费率：2019-07-15 ~ 2019-07-21 | 过去 合计：92.2% 注册用户首日上课率：2019-03-23 ~ 2019-03-29 | 过去 合计：91.06% 环比总结：随着在线教育用户群体的不断扩大，市场规模还将有更大的发展。权威机构预计未来5年，我国在线教育市场规模将保持10%左右的增长速度，到2022年，市场规模将达到2857亿元左右 盒马鲜生模式定位： 目标客户——25-35 岁的围绕家庭的互联网用户，集中在女性。 客户特点——对商品的新鲜度和品质是第一要求，对服务看的很重要。对价格的敏感度反而不高，所以盒马鲜生不提倡价格战。 线上+线下，仓店一体模式 每日优鲜模式定位： 围绕生鲜及日用品的B2C电商类应用，满足了各类白领、学生、家庭主妇等老百姓以优惠的价格，在线快速购买生鲜食品及日用品并快速送达的需求，商品涵盖水果、肉蛋、水产、蔬菜、饮品、乳品、零食、轻食、粮油等9个品类。（快、省） 线上 前置仓模式: 就是在社区和商圈周边半公里内设置仓库，每个前置仓的面积在80-130㎡不等，配送时长控制在2小时内。当区域订单超出既有前置仓的覆盖能力时，就增加数量。大家可以理解为京东的自营模式。这样做的好处是： 更好的用户体验每日优鲜目前有1000多个前置仓，因为离得消费者更近，可以保证用户在下单后一小时内送达。此外，在前置仓对不同的蔬果肉类有设置不同的保鲜区域，对商品的保鲜自然会比在快递路上要好得多。如此一来，每日优鲜就可以做到快速地把新鲜食品送到消费者手中，用户体验好了，复购率自然高，如此一来还可极大地降低获客成本。 更低的成本。在每日优鲜初期，不少人对前置仓提出质疑，认为成本高昂，实际上，这些成本都是固定成本，随着订单的增加，成本会被平摊掉。据每日优鲜对外公布的数据，如今每日优鲜每单的配送成本已经降低到和普通快递一样了 全品类精选这样做的好处是：降低备货库存，从而降低运营成本。和其他生鲜品要么注重水果，要么注重海鲜不同，每日优鲜的产品策略是覆盖全品类。但全品类并不意味着海量SKU(库存量单位)，每日优鲜实施的是“精选”策略，将整个平台SKU数控制在1000个左右，每个品种只给顾客一到两个选择 社交化和会员制在客户获取方面，每日优鲜采用的是流量思维，即注重老用户体验，让用户自我传播，获得新客户。注重口碑的好处是，每日优鲜的用户购买频次和复购率高的惊人：会员平均每年 60-70 次购买，每次购买 10 个左右 SKU(库存量单位)，一年人和商品连接 600-700 次，差不多是一般电商的三十倍。此外，有超过 40% 的新客户是通过会员推荐过来的。 供需关系对比 APP 商品来源 商品销售 仓储/配送 每日优鲜 自采 自有平台 自建仓库，自有物流团队 盒马鲜生 自采 自有平台 自建仓库，自有物流团队 盒马鲜生SWOT分析 优势：选址开店一方面可以实现线上线下流量的互相打通，一体化运营，让购物场景和体验更丰富；另一方面，盒马超市还是线上订单的前置仓 劣势：盒马鲜生也有一个无法避免的问题，盒马模式太重了，辐射面积有限，复制困难，更不可能像每日优鲜一样，遍布城市的每一个角落。开店成本高。 机会：由于种种条件所限，中国传统零售业在供应链、物流体系、渗透率上，比发达国家要滞后10余年。供货商要经过多个环节，才能让商品在终端门店接近消费者，不仅周期长，且进场费、上价费、促销费等各项费用奇高，推高了售价，厂家还要自担库存积压风险。盒马鲜生的买手模式，给盒马鲜生创造了打破传统的机会 威胁：新零售领域，京东等巨头也在积极布局。而且，盒马鲜生若想下沉至三四线地区，当地的生鲜价格有竞争优势。 每日优鲜SWOT分析 优势：对每日优鲜来说，前置仓周转平均周期为1.5天，生鲜耗损率不到1%，这是其他生鲜电商难以做到的。3年实现盈利，融资能力强，18年融资4.5亿，背靠腾讯 劣势：前置仓面积小，能容纳的生鲜品类和数量较少。精选SKU虽然能最大程度满足消费者所需，但是，容易出现补货预测不够精准的问题，造成缺货率较高 机会：由于种种条件所限，中国传统零售业在供应链、物流体系、渗透率上，比发达国家要滞后10余年。供货商要经过多个环节，才能让商品在终端门店接近消费者，不仅周期长，且进场费、上价费、促销费等各项费用奇高，推高了售价，厂家还要自担库存积压风险。盒马鲜生的买手模式，给盒马鲜生创造了打破传统的机会 威胁：其整套商业模型比较适合在一二线城市进行复制，若想下沉至三四线甚至以下的地区，就会遭遇本地社区生鲜品牌的强力狙击。“三四线城市的社区生鲜价格非常有竞争力，每日优鲜就显得太贵了。其次，盒马鲜生、超级物种，乃至京东的7fresh这类真正意义上打通线上线下的新零售不惜重金烧钱换市场，一旦这些巨头获得市场，其创造出的势能是前置仓类公司所无法比拟的，届时这些新零售商家也会给每日优鲜造成明显的分流压力]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[竞品分析：在线K12教育【轻学堂】]]></title>
    <url>%2Fblog%2F2017%2F12%2F12%2F%E7%AB%9E%E5%93%81%E5%88%86%E6%9E%90%EF%BC%9A%E5%9C%A8%E7%BA%BFK12%E6%95%99%E8%82%B2%E3%80%90%E8%BD%BB%E5%AD%A6%E5%A0%82%E3%80%91%2F</url>
    <content type="text"><![CDATA[项目背景 随着全球教育信息化的发展，在线K12教育市场呈现出爆发式增长，通过以下几组数据了解K12教育行业概况： 1.纪念日：2013年称为在线教育市场的元年，2014年平均每天有2.6家在线教育公司成立。 2.师生：2015年全国小学在校学生人数为 9692.18 万，对应专任教师 568.51 万；初中在校人数为 4311.95 万，对应的专任教师347.56 万；高中在校人数为 4037.69 万，对应专任教师 169.54 万。K12阶段总计在校学生数约18041.82万（约1.8亿），专任教师1085.61万。 3.学校：2015年全国公立小学： 19.05 万所，民办普通小学 5798 所；全国普通初中 5.24 万所；全国普通高中 2.49 万所。 K12阶段全国学校总数约为26.78万所。 从上述数据可以看出，现阶段的K12在线教育行业处于政策利好时期；并且从2013年以来互联网巨头和初创公司都开始发力K12在线教育，K12产品如雨后春笋般涌现；其次K12在线教育最大涉及人群约22亿，市场空间充裕 市场分析 市场规模预测 累计用户数：2017-08-05 ~ 2019-07-22 | 上线 合计：33.46万人 7日注册用户占比：2019-07-15 ~ 2019-07-21 | 过去 合计：91.24% 注册用户首日付费率：2019-07-15 ~ 2019-07-21 | 过去 合计：92.2% 注册用户首日上课率：2019-03-23 ~ 2019-03-29 | 过去 合计：91.06% 环比总结：随着在线教育用户群体的不断扩大，市场规模还将有更大的发展。权威机构预计未来5年，我国在线教育市场规模将保持10%左右的增长速度，到2022年，市场规模将达到2857亿元左右 线下教育存在弊端 TODO… 用户规模预测 TODO… 小节 TODO… 竞品分析 竞品选择 产品简介 产品定位-战略层 产品框架-范围层 产品结构图-结构层 产品界面图—框架层及表现层（登录页面） 产品界面图—框架层及表现层（首页） 用户分析 SWOT分析 建议小节 总结]]></content>
      <categories>
        <category>产品</category>
      </categories>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器解析和CSS（GPU）动画优化]]></title>
    <url>%2Fblog%2F2017%2F09%2F16%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%92%8CCSS%EF%BC%88GPU%EF%BC%89%E5%8A%A8%E7%94%BB%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[浏览器渲染提高动画的优化不得不提及浏览器是如何渲染一个页面。在从服务器中拿到数据后，浏览器会先做解析三类东西： 解析html,xhtml,svg这三类文档，形成dom树。 解析css，产生css rule tree。 解析js，js会通过api来操作dom tree和css rule tree。 解析完成之后，浏览器引擎会通过dom tree和css rule tree来构建rendering tree： rendering tree和dom tree并不完全相同，例如：&lt;head&gt;&lt;/head&gt;或display:none的东西就不会放在渲染树中。 css rule tree主要是完成匹配，并把css rule附加给rendering tree的每个element。 在渲染树构建完成后： 浏览器会对这些元素进行定位和布局，这一步也叫做reflow或者layout。 浏览器绘制这些元素的样式，颜色，背景，大小及边框等，这一步也叫做repaint。 然后浏览器会将各层的信息发送给GPU，GPU会将各层合成；显示在屏幕上。 渲染优化原理如上所说，渲染树构建完成后；浏览器要做的步骤： reflow ——&gt; repaint ——&gt; composite reflow和repaintreflow和repaint都是耗费浏览器性能的操作，这两者尤以reflow为甚；因为每次reflow，浏览器都要重新计算每个元素的形状和位置。 由于reflow和repaint都是非常消耗性能的，我们的浏览器为此做了一些优化。浏览器会将reflow和repaint的操作积攒一批，然后做一次reflow。但是有些时候，你的代码会强制浏览器做多次reflow。例如： 1234567var content = document.getElementById(&apos;content&apos;);content.style.width = 700px;var contentWidth = content.offsetWidth;content.style.backgound = &apos;red&apos;; 以上第三行代码，需要浏览器reflow后；再获取值，所以会导致浏览器多做一次reflow。 下面是一些针对reflow和repaint的最佳实践： 不要一条一条地修改dom的样式，尽量使用className一次修改。 将dom离线后修改 使用documentFragment对象在内存里操作dom。 先把dom节点display:none;（会触发一次reflow）。然后做大量的修改后，再把它显示出来。 clone一个dom节点在内存里，修改之后；与在线的节点相替换。 不要使用table布局，一个小改动会造成整个table的重新布局。 transform和opacity只会引起合成，不会引起布局和重绘。 从上述的最佳实践中你可能发现，动画优化一般都是尽可能地减少reflow、repaint的发生。关于哪些属性会引起reflow、repaint及composite，你可以在[这个网站]找到(https://csstriggers.com/) composite在reflow和repaint之后，浏览器会将多个复合层传入GPU；进行合成工作，那么合成是如何工作的呢？ 假设我们的页面中有A和B两个元素，它们有absolute和z-index属性；浏览器会重绘它们，然后将图像发送给GPU；然后GPU将会把多个图像合成展示在屏幕上。 1234567891011121314151617&lt;style&gt;#a, #b &#123;position: absolute;&#125;#a &#123;left: 30px;top: 30px;z-index: 2;&#125;#b &#123;z-index: 1;&#125;&lt;/style&gt;&lt;div id=&quot;#a&quot;&gt;A&lt;/div&gt;&lt;div id=&quot;#b&quot;&gt;B&lt;/div&gt; 在这个例子中，对于动画的每一帧；浏览器会计算元素的几何形状，渲染新状态的图像；并把它们发送给GPU。（你没看错，position也会引起浏览器重排的）尽管浏览器做了优化，在repaint时，只会repaint部分区域；但是我们的动画仍然不够流畅。 因为重排和重绘发生在动画的每一帧，一个有效避免reflow和repaint的方式是我们仅仅画两个图像；一个是a元素，一个是b元素及整个页面；我们将这两张图片发送给GPU，然后动画发生的时候；只做两张图片相对对方的平移。也就是说，仅仅合成缓存的图片将会很快；这也是GPU的优势——它能非常快地以亚像素精度地合成图片，并给动画带来平滑的曲线。 为了仅发生composite，我们做动画的css property必须满足以下三个条件： 不影响文档流。 不依赖文档流。 不会造成重绘。 满足以上以上条件的css property只有transform和opacity。你可能以为position也满足以上条件，但事实不是这样，举个例子left属性可以使用百分比的值，依赖于它的offset parent。还有em、vh等其他单位也依赖于他们的环境。 我们使用translate来代替left 12345678910111213141516171819202122232425&lt;style&gt;#a, #b &#123;position: absolute;&#125;#a &#123;left: 10px;top: 10px;z-index: 2;animation: move 1s linear;&#125;#b &#123;left: 50px;top: 50px;z-index: 1;&#125;@keyframes move &#123;from &#123; transform: translateX(0); &#125;to &#123; transform: translateX(70px); &#125;&#125;&lt;/style&gt;&lt;div id=&quot;#a&quot;&gt;A&lt;/div&gt;&lt;div id=&quot;#b&quot;&gt;B&lt;/div&gt; 浏览器在动画执行之前就知道动画如何开始和结束，因为浏览器没有看到需要reflow和repaint的操作；浏览器就会画两张图像作为复合层，并将它们传入GPU。 这样做有两个优势： 动画将会非常流畅 动画不在绑定到CPU，即使js执行大量的工作；动画依然流畅。 看起来性能问题好像已经解决了？在下文你会看到GPU动画的一些问题。 GPU是如何合成图像的GPU实际上可以看作一个独立的计算机，它有自己的处理器和存储器及数据处理模型。当浏览器向GPU发送消息的时候，就像向一个外部设备发送消息。 你可以把浏览器向GPU发送数据的过程，与使用ajax向服务器发送消息非常类似。想一下，你用ajax向服务器发送数据，服务器是不会直接接受浏览器的存储的信息的。你需要收集页面上的数据，把它们放进一个载体里面（例如JSON），然后发送数据到远程服务器。 同样的，浏览器向GPU发送数据也需要先创建一个载体；只不过GPU距离CPU很近，不会像远程服务器那样可能几千里那么远。但是对于远程服务器，2秒的延迟是可以接受的；但是对于GPU，几毫秒的延迟都会造成动画的卡顿。 浏览器向GPU发送的数据载体是什么样？这里给出一个简单的制作载体，并把它们发送到GPU的过程。 画每个复合层的图像 准备图层的数据 准备动画的着色器（如果需要） 向GPU发送数据 所以你可以看到，每次当你添加transform:translateZ(0)或will-change：transform给一个元素，你都会做同样的工作。重绘是非常消耗性能的，在这里它尤其缓慢。在大多数情况，浏览器不能增量重绘。它不得不重绘先前被复合层覆盖的区域。 隐式合成还记得刚才a元素和b元素动画的例子吗？现在我们将b元素做动画，a元素静止不动。 和刚才的例子不同，现在b元素将拥有一个独立复合层；然后它们将被GPU合成。但是因为a元素要在b元素的上面（因为a元素的z-index比b元素高），那么浏览器会做什么？浏览器会将a元素也单独做一个复合层！ 所以我们现在有三个复合层a元素所在的复合层、b元素所在的复合层、其他内容及背景层。 一个或多个没有自己复合层的元素要出现在有复合层元素的上方，它就会拥有自己的复合层；这种情况被称为隐式合成。 浏览器将a元素提升为一个复合层有很多种原因，下面列举了一些： 3d或透视变换css属性，例如translate3d,translateZ等等（js一般通过这种方式，使元素获得复合层） &lt;video&gt;&lt;iframe&gt;&lt;canvas&gt;等元素。 混合插件（如flash）。 元素自身的 opacity和transform 做 CSS 动画。 拥有css过滤器的元素。 使用will-change属性。 position:fixed。 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染) 这看起来css动画的性能瓶颈是在重绘上，但是真实的问题是在内存上： 内存占用使用GPU动画需要发送多张渲染层的图像给GPU，GPU也需要缓存它们以便于后续动画的使用。 一个渲染层，需要多少内存占用？为了便于理解，举一个简单的例子；一个宽、高都是300px的纯色图像需要多少内存？ 300 300 4 = 360000字节，即360kb。这里乘以4是因为，每个像素需要四个字节计算机内存来描述。 假设我们做一个轮播图组件，轮播图有10张图片；为了实现图片间平滑过渡的交互；为每个图像添加了will-change:transform。这将提升图像为复合层，它将多需要19mb的空间。800 600 4 * 10 = 1920000。 仅仅是一个轮播图组件就需要19m的额外空间！ 在chrome的开发者工具中打开setting——》Experiments——》layers可以看到每个层的内存占用。如图所示： GPU动画的优点和缺点现在我们可以总结一下GPU动画的优点和缺点： 每秒60帧，动画平滑、流畅。 一个合适的动画工作在一个单独的线程，它不会被大量的js计算阻塞。 3D“变换”是便宜的。 缺点： 提升一个元素到复合层需要额外的重绘，有时这是慢的。（即我们得到的是一个全层重绘，而不是一个增量） 绘图层必须传输到GPU。取决于层的数量和传输可能会非常缓慢。这可能让一个元素在中低档设备上闪烁。 每个复合层都需要消耗额外的内存，过多的内存可能导致浏览器的崩溃。 如果你不考虑隐式合成，而使用重绘；会导致额外的内存占用，并且浏览器崩溃的概率是非常高的。 我们会有视觉假象，例如在Safari中的文本渲染，在某些情况下页面内容将消失或变形。 优化技巧 避免隐式合成 保持动画的对象的z-index尽可能的高。理想的，这些元素应该是body元素的直接子元素。当然，这不是总可能的。所以你可以克隆一个元素，把它放在body元素下仅仅是为了做动画。 将元素上设置will-change CSS属性，元素上有了这个属性，浏览器会提升这个元素成为一个复合层（不是总是）。这样动画就可以平滑的开始和结束。但是不要滥用这个属性，否则会大大增加内存消耗。 动画中只使用transform和opacity如上所说，transform和opacity保证了元素属性的变化不影响文档流、也不受文档流影响；并且不会造成repaint。有些时候你可能想要改变其他的css属性，作为动画。例如：你可能想使用background属性改变背景： 12345678910&lt;div class=&quot;bg-change&quot;&gt;&lt;/div&gt;.bg-change &#123; width: 100px; height: 100px; background: red; transition: opacity 2s;&#125;.bg-change:hover &#123; background: blue;&#125; 在这个例子中，在动画的每一步；浏览器都会进行一次重绘。我们可以使用一个复层在这个元素上面，并且仅仅变换opacity属性： 1234567891011121314151617181920&lt;div class=&quot;bg-change&quot;&gt;&lt;/div&gt;&lt;style&gt;.bg-change &#123; width: 100px; height: 100px; background: red;&#125;.bg-change::before &#123; content: &apos;&apos;; display: block; width: 100%; height: 100%; background: blue; opacity: 0; transition: opacity 20s;&#125;.bg-change:hover::before &#123; opacity: 1;&#125;&lt;/style&gt; 减小复合层的尺寸看一下两张图片，有什么不同吗？ 这两张图片视觉上是一样的，但是它们的尺寸一个是39kb；另外一个是400b。不同之处在于，第二个纯色层是通过scale放大10倍做到的。 12345678910111213141516171819&lt;div id=&quot;a&quot;&gt;&lt;/div&gt;&lt;div id=&quot;b&quot;&gt;&lt;/div&gt;&lt;style&gt;#a, #b &#123;will-change: transform;&#125;#a &#123;width: 100px;height: 100px;&#125;#b &#123;width: 10px;height: 10px;transform: scale(10);&#125;&lt;/style&gt; 对于图片，你要怎么做呢？你可以将图片的尺寸减少5%——10%，然后使用scale将它们放大；用户不会看到什么区别，但是你可以减少大量的存储空间。 用css动画而不是js动画css动画有一个重要的特性，它是完全工作在GPU上。因为你声明了一个动画如何开始和如何结束，浏览器会在动画开始前准备好所有需要的指令；并把它们发送给GPU。而如果使用js动画，浏览器必须计算每一帧的状态；为了保证平滑的动画，我们必须在浏览器主线程计算新状态；把它们发送给GPU至少60次每秒。除了计算和发送数据比css动画要慢，主线程的负载也会影响动画； 当主线程的计算任务过多时，会造成动画的延迟、卡顿。 所以尽可能地使用基于css的动画，不仅仅更快；也不会被大量的js计算所阻塞。 优化技巧总结 减少浏览器的重排和重绘的发生。 不要使用table布局。 css动画中尽量只使用transform和opacity，这不会发生重排和重绘。 尽可能地只使用css做动画。 避免浏览器的隐式合成。 改变复合层的尺寸。 参考GPU合成主要参考： https://www.smashingmagazine…. 哪些属性会引起reflow、repaint及composite，你可以在这个网站找到： https://csstriggers.com/]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解 ES6 的 async/await]]></title>
    <url>%2Fblog%2F2017%2F07%2F31%2F%E7%90%86%E8%A7%A3-ES6-%E7%9A%84-async-await%2F</url>
    <content type="text"><![CDATA[async 和 await 在干什么任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？ 如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日…… 如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？ async 起什么作用这个问题的关键在于，async 函数是怎么处理它的返回值的！ 我们当然希望它能直接通过 return 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么： 123456async function testAsync() &#123; return &quot;hello async&quot;;&#125;const result = testAsync();console.log(result); 看到输出就恍然大悟了——输出的是一个 Promise 对象。1Promise &#123; &apos;hello async&apos; &#125; 所以，async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样123testAsync().then(v =&gt; &#123; console.log(v); // 输出 hello async&#125;); 现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。 联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。 那么下一个关键点就在于 await 关键字了。 await 到底在等什么一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。 因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行 123456789101112131415function getSomething() &#123; return &quot;something&quot;;&#125;async function testAsync() &#123; return Promise.resolve(&quot;hello async&quot;);&#125;async function test() &#123; const v1 = await getSomething(); const v2 = await testAsync(); console.log(v1, v2);&#125;test(); await 等到了要等的，然后呢await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await 帮我们做了什么上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。 现在举例，用 setTimeout 模拟耗时的异步操作，先来看看不用 async/await 会怎么写 123456789function takeLongTime() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000); &#125;);&#125;takeLongTime().then(v =&gt; &#123; console.log(&quot;got&quot;, v);&#125;); 如果改用 async/await 呢，会是这样 123456789101112function takeLongTime() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000); &#125;);&#125;async function test() &#123; const v = await takeLongTime(); console.log(v);&#125;test(); 眼尖的同学已经发现 takeLongTime() 没有申明为 async。实际上，takeLongTime() 本身就是返回的 Promise 对象，加不加 async 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。 又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？ async/await 的优势在于处理 then 链单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。 假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 setTimeout 来模拟异步操作： 123456789101112131415161718192021222324/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125; 现在用 Promise 方式来实现这三个步骤的处理 12345678910111213141516171819function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt();// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms 输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd()计算的结果一致。如果用 async/await 来实现呢，会是这样 1234567891011async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt(); 结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样 还有更酷的现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。 1234567891011121314function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(m, n) &#123; console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(m + n);&#125;function step3(k, m, n) &#123; console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`); return takeLongTime(k + m + n);&#125; 这回先用 async/await 来写： 12345678910111213141516async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt();// step1 with 300// step2 with 800 = 300 + 500// step3 with 1800 = 300 + 500 + 1000// result is 2000// doIt: 2907.387ms 除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？ 12345678910111213141516171819function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; &#123; return step2(time1, time2) .then(time3 =&gt; [time1, time2, time3]); &#125;) .then(times =&gt; &#123; const [time1, time2, time3] = times; return step3(time1, time2, time3); &#125;) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt(); 有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！ 写在最后就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理3个步骤，再等待所有结果，又该怎么处理呢？ 阮一峰老师已经说过了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器原生JS-Base64编码解码]]></title>
    <url>%2Fblog%2F2016%2F08%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%94%9F%E6%94%AF%E6%8C%81JS-Base64%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[原生atob和btoa方法实际上，从IE10+浏览器开始，所有浏览器就原生提供了Base64编码解码方法，不仅可以用于浏览器环境，Service Worker环境也可以使用。 方法名就是atob和btoa，具体语法如下： Base64解码 语法为（浏览器中）： 1var decodedData = window.atob(encodedData); 或者（浏览器或js Worker线程中）： 1var decodedData = self.atob(encodedData); 例如： window.atob(&apos;RERE&apos;); // 返回：&apos;DDD&apos; 记住atobatob这个方法名称乍一看，很奇怪，不知道这个单词什么意思。我们可以理解为 A to B，也就是从A到B。这里的B指的就是Base64吗？猜错了！A指的才是Base64，反的，A才是Base64，和首字母对应关系是反的。 因此，atob表示Base64字符to普通字符，也就是Base64解码。 Base64编码语法为（浏览器中）：1var encodedData = window.btoa(stringToEncode); 或者（浏览器或js Worker线程中）： 1var encodedData = self.btoa(stringToEncode); 例如：12window.btoa('DDD');// 返回：'RERE' 记住btoa方法btoa这个方法名称乍一看，很奇怪，不知道这个单词什么意思。我们可以理解为 B to A，也就是从B到A。那B指什么，A指什么呢？和atob方法一样，B指的是普通字符串，A指的是Base64字符。 因此，btoa方法表示普通字符to Base64字符，也就是Base64编码。 IE8/IE9的polyfill当下，仍有不少PC项目还需要兼容IE9，所以，我们可以专门针对这些浏览器再引入一段ployfill脚本或者一个JS文件即可。ployfill JS脚本戳这里，或者直接右键这里下载源文件！实际使用，我们可以借助IE条件注释无缝对接。 也就是HTML中嵌入下面一段代码：123&lt;!--[if IE]&gt;&lt;script src="./base64-polyfill.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; [if IE]表示所有IE浏览器，由于IE10+浏览器已经放弃了著名的IE条件注释的支持，Chrome等浏览器本身就不支持这个IE私有语法，因此，很天然的，上面一段script引入只在IE9-浏览器下有效。而我们本来就希望只IE8，IE9浏览器引入ployfill，于是正好完美衔接上。 也就是原生支持atob和btoa方法的浏览器认为就是一段无需关心的HTML注释，不支持atob和btoa的IE9及其以下浏览器则会加载我们的base64-polyfill.js，使浏览器也支持window.btoa和window.atob这个语法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些总结]]></title>
    <url>%2Fblog%2F2016%2F07%2F31%2F%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[如何渲染几万条数据并不卡住界面MDN文档 &lt;script&gt; setTimeout(() =&gt; { // 插入十万条数据 const total = 100000; // 一次插入 20 条，如果觉得性能不好就减少 const once = 20; // 渲染数据总共需要几次 const loopCount = total / once; let countOfRender = 0; let ul = document.querySelector(&quot;ul&quot;); function add() { // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; once; i++) { const li = document.createElement(&quot;li&quot;); li.innerText = Math.floor(Math.random() * total); fragment.appendChild(li); } ul.appendChild(fragment); countOfRender += 1; loop(); } function loop() { if (countOfRender &lt; loopCount) { window.requestAnimationFrame(add); } } loop(); }, 0); &lt;/script&gt; 监控对于代码运行错误，通常的办法是使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归 对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。 1234567window.onerror = function(msg, url, line, col, error) &#123; // 直接将错误打印到控制台 alert(JSON.stringify(arguments)); // 方便在未打开控制台的时候，记录错误对象 window.demoError = arguments;&#125; 对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求。 存储cookie，localStorage，sessionStorage，indexDB 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储. 对于 cookie，我们还需要注意安全性。 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 框架通识 MVVM 由以下三个内容组成 View：界面 Model：数据模型 ViewModel：作为桥梁负责沟通 View 和 Model 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合 在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。 Angular脏数据检测当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。 Vue数据劫持Vue 内部使用了 Obeject.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get的事件。 12345678910111213141516171819202122232425262728293031var data = &#123; name: &apos;test&apos; &#125;observe(data)let name = data.name // -&gt; get valuedata.name = &apos;yyy&apos; // -&gt; change valuefunction observe(obj) &#123; // 判断类型 if (!obj || typeof obj !== &apos;object&apos;) &#123; return &#125; Object.keys(data).forEach(key =&gt; &#123; defineReactive(data, key, data[key]) &#125;)&#125;function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log(&apos;get value&apos;) return val &#125;, set: function reactiveSetter(newVal) &#123; console.log(&apos;change value&apos;) val = newVal &#125; &#125;)&#125; 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅 123&lt;div&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt; 在解析如上模板代码时，遇到 就会给属性 name 添加发布订阅。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 通过 Dep 解耦class Dep &#123; constructor() &#123; this.subs = [] &#125; addSub(sub) &#123; // sub 是 Watcher 实例 this.subs.push(sub) &#125; notify() &#123; this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125;// 全局属性，通过该属性配置 WatcherDep.target = nullfunction update(value) &#123; document.querySelector(&apos;div&apos;).innerText = value&#125;class Watcher &#123; constructor(obj, key, cb) &#123; // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null &#125; update() &#123; // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) &#125;&#125;var data = &#123; name: &apos;yck&apos; &#125;observe(data)// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作new Watcher(data, &apos;name&apos;, update)// update Dom innerTextdata.name = &apos;yyy&apos; 接下来,对 defineReactive 函数进行改造 1234567891011121314151617181920212223function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log(&apos;get value&apos;) // 将 Watcher 添加到订阅 if (Dep.target) &#123; dp.addSub(Dep.target) &#125; return val &#125;, set: function reactiveSetter(newVal) &#123; console.log(&apos;change value&apos;) val = newVal // 执行 watcher 的 update 方法 dp.notify() &#125; &#125;)&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 闭包]]></title>
    <url>%2Fblog%2F2015%2F12%2F22%2FJavaScript-%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。 变量的作用域 要理解闭包首先必须理解JS变量的作用域，无非就是两种：全局变量和局部变量 12345var b = 123;function fn()&#123; alert(b);&#125;fn(); // 123 我的理解是，闭包就是能够读取其他函数内部变量的函数]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中 apply 、call 的详解]]></title>
    <url>%2Fblog%2F2015%2F12%2F10%2FJavaScript-%E4%B8%AD-apply-%E3%80%81call-%E7%9A%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1alert(&apos;Hello World!&apos;); apply 和 call 的区别 ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。 apply( ) apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。 123456789var obj = &#123; name : &apos;denton&apos;&#125;function func(firstName, lastName)&#123; console.log(firstName + &apos; &apos; + this.name + &apos; &apos; + lastName);&#125;func.apply(obj, [&apos;A&apos;, &apos;B&apos;]); // A denton B 可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象。参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素。 call( ) call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。 123456789var obj = &#123; name: &apos;denton&apos;&#125;function func(firstName, lastName) &#123; console.log(firstName + &apos; &apos; + this.name + &apos; &apos; + lastName);&#125;func.call(obj, &apos;C&apos;, &apos;D&apos;); // C denton D 对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中。 对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。 apply 和 call 的用法改变 this 指向12345678910111213141516var obj = &#123; name: &apos;denton&apos;&#125;function func() &#123; console.log(this.name);&#125;func.call(obj); // denton// 我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。// 此处 func 函数里其实相当于function func() &#123; console.log(obj.name);&#125; 借用别的对象的方法1234567891011var Person1 = function () &#123; this.name = &apos;denton&apos;;&#125;var Person2 = function () &#123; this.getname = function () &#123; console.log(this.name); &#125; Person1.call(this);&#125;var person = new Person2();person.getname(); // denton 从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。 调用函数 apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数。 1234function func() &#123; console.log(&apos;denton&apos;);&#125;func.call(); // denton call 和 bind 的区别在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容。它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。它们之间的区别有以下两点。 bind 发返回值是函数12345678910var obj = &#123; name: &apos;denton&apos;&#125;function func() &#123; console.log(this.name);&#125;var func1 = func.bind(obj);func1(); // denton bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。 参数的使用123456789function func(a, b, c) &#123; console.log(a, b, c);&#125;var func1 = func.bind(null,&apos;linxin&apos;);func(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;); // A B Cfunc1(&apos;A&apos;, &apos;B&apos;, &apos;C&apos;); // linxin A Bfunc1(&apos;B&apos;, &apos;C&apos;); // linxin B Cfunc.call(null, &apos;linxin&apos;); // linxin undefined undefined call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排。 在低版本浏览器没有 bind 方法，我们也可以自己实现一个。 12345678910if (!Function.prototype.bind) &#123; Function.prototype.bind = function () &#123; var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () &#123; // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中 this 的详解]]></title>
    <url>%2Fblog%2F2015%2F12%2F10%2FJavaScript-%E4%B8%AD-this-%E7%9A%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[this 的指向 this 是 JS 中定义的关键字，它自动定义于每一个函数域内，但是它的指向却让人很迷惑。 在实际应用中，this 的指向大致可以分为以下四种情况。 1.作为普通函数调用 当函数作为一个普通函数被调用，this 指向全局对象。在浏览器里，全局对象就是 window。 12345window.name = &apos;denton&apos;;function getName()&#123; console.log(this.name);&#125;getName(); // denton 可以看出，此时 this 指向了全局对象 window。 在ECMAScript5的严格模式下，这种情况 this 已经被规定不会指向全局对象了，而是 undefined。 12345&apos;use strict&apos;;function fun()&#123; console.log(this);&#125;fun(); // undefined 2.作为对象的方法调用 当函数作为一个对象里的方法被调用，this 指向该对象 12345678var obj = &#123; name : &apos;denton&apos;, getName : function()&#123; console.log(this.name); &#125;&#125;obj.getName(); // denton 如果把对象的方法赋值给一个变量，再调用这个变量： 12345678var obj = &#123; fun1 : function()&#123; console.log(this); &#125;&#125;var fun2 = obj.fun1;fun2(); // window 此时调用 fun2 方法 输出了 window 对象，说明此时 this 指向了全局对象。给 fun2 赋值，其实是相当于： 123var fun2 = function()&#123; console.log(this);&#125; 可以看出，此时的 this 已经跟 obj 没有任何关系了。这时 fun2 是作为普通函数调用。 3.作为构造函数调用JS中没有类，但是可以从构造器中创建对象，并提供了 new 运算符来进行调用该构造器。构造器的外表跟普通函数一样，大部分的函数都可以当做构造器使用。当构造函数被调用时，this 指向了该构造函数实例化出来的对象。 12345var Person = function()&#123; this.name = &apos;denton&apos;;&#125;var obj = new Person();console.log(obj.name); // denton 如果构造函数显式的返回一个对象，那么 this 则会指向该对象。 12345678var Person = function()&#123; this.name = &apos;DDD&apos;; return &#123; name : &apos;denton&apos; &#125;&#125;var obj = new Person();console.log(obj.name); // denton 如果该函数不用 new 调用，当作普通函数执行，那么 this 依然指向全局对象。 4.call() 或 apply() 调用 通过调用函数的 call() 或 apply() 方法可动态的改变 this 的指向。 12345678910111213var obj1 = &#123; name : &apos;denton&apos;, getName : function()&#123; console.log(this.name); &#125;&#125;var obj2 = &#123; name : &apos;DDD&apos;&#125;obj1.getName(); // dentonobj1.getName.call(obj2); // DDDobj1.getName.apply(obj2); // DDD 这两个方法在js中都是非常常用的方法，可以阅读下一篇：JavaScript 中 apply 、call 的详解。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS获取服务器端时间]]></title>
    <url>%2Fblog%2F2015%2F12%2F10%2FJS%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[用JS做时间校正，获取本机时间，是存在bug的。 使用JS也可获取到服务器时间，原理是使用 Ajax请求，返回的头部信息就含有服务器端的时间信息，获取到就可以了。以下： 依赖于JQuery 123function getServerDate()&#123; return new Date($.ajax(&#123;async: false&#125;).getResponseHeader(&quot;Date&quot;));&#125; 以上函数返回的就是一个Date对象，注意在使用ajax时必须同步，要不然无法返回时间日期。 无需填写请求链接； 如果服务器时间和本地时间有时差，需要做校正。 原生方法 12345678910111213function getServerDate()&#123; var xhr = null; if(window.XMLHttpRequest)&#123; xhr = new window.XMLHttpRequest(); &#125;else&#123; // IE xhr = new ActiveObject(&quot;Microsoft&quot;) &#125; xhr.open(&quot;GET&quot;,&quot;/&quot;,false) // false不可变 xhr.send(null); var date = xhr.getResponseHeader(&quot;Date&quot;); return new Date(date);&#125; 同样返回的是一个Date对象，xhr.open()必须使用同步; 无需填写请求链接;open，send，和getResponseHeader 必须按序编写。 如需使用异步请求，可监听onreadystatechange状态来做不同的操作。 代码如下：12345678910111213141516171819function getServerDate()&#123; var xhr = null; if(window.XMLHttpRequest)&#123; xhr = new window.XMLHttpRequest(); &#125;else&#123; // ie xhr = new ActiveObject(&quot;Microsoft&quot;) &#125; xhr.open(&quot;GET&quot;,&quot;/&quot;,true); xhr.send(null); xhr.onreadystatechange=function()&#123; var time,date; if(xhr.readyState == 2)&#123; time = xhr.getResponseHeader(&quot;Date&quot;); date = new Date(time); console.log(date); &#125; &#125;&#125; 使用异步不是很方便返回时间。 这里的readyState有四种状态，方便做不同处理： 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 失败状态，status的值： 200: “OK” 404: 未找到页面]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
